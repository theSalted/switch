<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>crisp-game-lib</title>
    <meta
      name="viewport"
      content="width=device-width, height=device-height,
    user-scalable=no, initial-scale=1, maximum-scale=1"
    />
    <script src="https://unpkg.com/sounds-some-sounds@1.0.5/build/index.js"></script>
    <script src="https://unpkg.com/gif-capture-canvas@1.1.0/build/index.js"></script>
    <script src="https://unpkg.com/terser@4.6.11/dist/bundle.min.js"></script>
    <script src="https://unpkg.com/pixi.js@5.3.0/dist/pixi.min.js"></script>
    <script src="https://unpkg.com/pixi-filters@3.1.1/dist/pixi-filters.js"></script>
    <script>
      var module = {};
    </script>
    <script src="https://unpkg.com/lodash.clonedeep@4.5.0/index.js"></script>
    <script src="https://abagames.github.io/crisp-game-lib/bundle.js"></script>

<script>
title = "SWITCH";

description = `[PRESS] - CYAN / RED
[HOLD] - YELLOW
`;

characters = [];

const sequences = [
  ['cyan', 'cyan', 'cyan', 'red', 'yellow'],
  ['red', 'red', 'red', 'cyan', 'yellow'],
  ['cyan', 'cyan', 'cyan', 'cyan', 'cyan'],
  ['red', 'red', 'red', 'red', 'red'],
  ['cyan', 'cyan', 'cyan', 'red', 'cyan'],
  ['red', 'red', 'red', 'cyan', 'red'],
  ['yellow', 'yellow', 'yellow', 'yellow', 'yellow'],
  ['yellow', 'yellow', 'cyan', 'yellow', 'yellow'],
  ['yellow', 'yellow', 'red', 'yellow', 'yellow']
];

const G = {
  WIDTH: 200,
  HEIGHT: 200,
  
  PLAYER_WIDTH: 10,
  PLAYER_HEIGHT: 100,
  
  HITBOX_SIZE: 10,
  
  HOLD_DELAY : 20,
  DEFAULT_SPEED: 3,
  
  BULLET_PER_SEQ: 5
}

options = {
  theme : "crt",
  viewSize: {x: G.WIDTH, y: G.HEIGHT}
};

function update() {
  // INIT
  if (!ticks) {
    
    // PLAYER init
    player = {
      pos: vec(G.WIDTH * 0.1, G.HEIGHT * 0.5),
      size: vec(G.PLAYER_WIDTH, G.PLAYER_HEIGHT),
      delayCounter: 0,
      color: "cyan"
    };
    
    hitbox = times(G.BULLET_PER_SEQ, (i) => {
      return {
        pos: vec(G.WIDTH + G.HITBOX_SIZE, G.HEIGHT * 0.5),
        size: vec(G.HITBOX_SIZE, G.HITBOX_SIZE),
        index: i,
        color: "cyan",
        isReadyForQueue : false,
        isReleased: false
      }
    });
    
    numFired = 0;
    needNewSeq = true;
    timer = 0;
    // Alternating Bool every update
    isTick = true;
  }
  
  // UPDATE STARTs HERE
  
  // UPDATE for input
  // update input is pressed
  if (input.isPressed) {
    // animation: Bop (expand when hold)
    if(player.size.y <= 105) {
      player.size.x += 0.1
      player.size.y += 0.5
    } else {
      player.size.x -= 0.05
      player.size.y -= 0.25
    }
    
    // animation: Shake
    if(isTick) {
      player.pos.x += 1
      player.pos.y += 1
    } else {
      player.pos.x -= 1
      player.pos.y -= 1
    }
    
    // delay count up
    player.delayCounter += 1;
  }
  // update when input is released
  if (input.isJustReleased) {
    // color switch
    if (player.color == "cyan") {
      player.color = "red"
    } else {
      player.color = "cyan"
    }
    
    // player animation recovery (reset size and position)
    player.size = vec(G.PLAYER_WIDTH, G.PLAYER_HEIGHT)
    player.pos = vec(G.WIDTH * 0.1, G.HEIGHT * 0.5)
    
    // delay reset
    player.delayCounter = 0;
  }
  
  
  // UPDATE for hitbox
  hitbox.forEach((h) => {
    // Fire counter
    if (needNewSeq && timer < 500) {
      timer += 1;
      numFired = 0;
    } else {
      if(needNewSeq) {
        seq = sequences[Math.floor(Math.random() * sequences.length)]
        needNewSeq = false
      }
      
      h.color = seq[h.index]
      if(h.index == numFired) {
        h.isReadyForQueue = true
      }
      
      if (h.isReadyForQueue) {
        if(h.pos.x > G.WIDTH * 0.95) {
          h.pos.x -= G.DEFAULT_SPEED
          h.size.x = G.HITBOX_SIZE
          h.isSlowedDown = false;
        } else {
          h.isReadyForQueue = false
          h.isReleased = true
        }
      }
      
      if(h.isReleased) {
        if(h.pos.x < G.WIDTH * 0.9) {
          h.isSlowedDown = false;
          h.pos.x -= G.DEFAULT_SPEED
          h.size.x = G.HITBOX_SIZE
        } else {
          h.isSlowedDown = true;
          h.pos.x -= G.DEFAULT_SPEED * 0.1
          h.size.x = G.HITBOX_SIZE * 0.5
        }
      }
      
      if(h.pos.x < G.WIDTH * 0.7) {
        numFired = h.index + 1
      }
      
      
      //reset hitbox
      if(h.pos.x <= player.pos.x) {
        h.pos.x = G.WIDTH + h.size.x
        addScore(100 + h.index * 20)
        player.isHit = true;
        h.isReadyForQueue = false;
        h.isReleased = false;
        if(G.BULLET_PER_SEQ == numFired) {
          needNewSeq = true;
          timer = 0;
        }
        //numFired += 1
      }
      
      // RENDERER 
      //renderer for hitbox
      color(h.color);
      
      box(h.pos.x, h.pos.y, h.size.x, h.size.y)
      
      
      if(!h.isSlowedDown) {
        color(h.color);
              
        particle(
            h.pos.x + 2, // x coordinate
            h.pos.y, // y coordinate
            4, // The number of particles
            1, // The speed of the particles
            0, // The emitting angle
            PI/2  // The emitting width
        );
      }
    }
    
  })
  // define slowdown boundaries
  // slowdown behavior
  
  // hitbox reset 
  
  
  // UPDATE for player
  if(player.isHit) {
    player.size.x = G.PLAYER_WIDTH * 0.5
    player.isHit = false;
  }
  
  if(player.size.x < G.PLAYER_WIDTH) {
    player.size.x += 0.3
  }
  
  if(player.size.x > G.PLAYER_WIDTH) {
    player.size.x = G.PLAYER_WIDTH
  }
  
  if(player.delayCounter >= G.HOLD_DELAY) {
    // yellow when hold
    player.color = "yellow"
  }
  
  
  // renderer for player
  color(player.color)
  const cyanDontMatch = box(player.pos.x, player.pos.y, player.size.x, player.size.y).isColliding.rect.cyan && player.color != "cyan";
  const redDontMatch = box(player.pos.x, player.pos.y, player.size.x, player.size.y).isColliding.rect.red && player.color != "red";
  const yellowDontMatch = box(player.pos.x, player.pos.y, player.size.x, player.size.y).isColliding.rect.yellow && player.color != "yellow";
  
  if(cyanDontMatch || redDontMatch || yellowDontMatch) {
    end();
  }
  
  // Particles
  if(player.size.x < G.PLAYER_WIDTH) {
    color(player.color)
    particle(
      player.pos.x + 5, // x coordinate
      player.pos.y, // y coordinate
      20, // The number of particles
      3, // The speed of the particles
      0, // The emitting angle
      3  // The emitting width
    );
  }
  
  // UPDATE for TICK TOCK
  // alternate boolean
  if(isTick) {
    isTick = false;
  } else {
    isTick = true;
  }
}

addEventListener("load", onLoad);
</script>

  </head>
  <body style="background: #ddd"></body>
</html>
