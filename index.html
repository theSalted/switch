<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>crisp-game-lib</title>
    <meta
      name="viewport"
      content="width=device-width, height=device-height,
    user-scalable=no, initial-scale=1, maximum-scale=1"
    />
    <script src="https://unpkg.com/sounds-some-sounds@1.0.5/build/index.js"></script>
    <script src="https://unpkg.com/gif-capture-canvas@1.1.0/build/index.js"></script>
    <script src="https://unpkg.com/terser@4.6.11/dist/bundle.min.js"></script>
    <script src="https://unpkg.com/pixi.js@5.3.0/dist/pixi.min.js"></script>
    <script src="https://unpkg.com/pixi-filters@3.1.1/dist/pixi-filters.js"></script>
    <script>
      var module = {};
    </script>
    <script src="https://unpkg.com/lodash.clonedeep@4.5.0/index.js"></script>
    <script src="https://abagames.github.io/crisp-game-lib/bundle.js"></script>

<script>
title = "SWITCH";

description = `
`;

characters = [];

const sequences = [
  ['b', 'b', 'b', 'r', 'r']
];

const G = {
  WIDTH: 200,
  HEIGHT: 200,
  
  PLAYER_WIDTH: 10,
  PLAYER_HEIGHT: 100,
  
  HITBOX_SIZE: 10,
  
  HOLD_DELAY : 20,
  DEFAULT_SPEED: 3
}

options = {
  theme : "crt",
  viewSize: {x: G.WIDTH, y: G.HEIGHT}
};

function update() {
  // INIT
  if (!ticks) {
    
    // PLAYER init
    player = {
      pos: vec(G.WIDTH * 0.1, G.HEIGHT * 0.5),
      size: vec(G.PLAYER_WIDTH, G.PLAYER_HEIGHT),
      delayCounter: 0,
      isCyan: true
    };
    
    // HitBox Init
    hitbox = {
      pos: vec(G.WIDTH + G.HITBOX_SIZE, G.HEIGHT * 0.5),
      size: vec(G.HITBOX_SIZE, G.HITBOX_SIZE),
      isCyan: true
    }
    // Alternating Bool every update
    isTick = true;
  }
  
  // UPDATE STARTs HERE
  
  // UPDATE for input
  // update input is pressed
  if (input.isPressed) {
    // animation: Bop (expand when hold)
    if(player.size.x <= 11) {
      player.size.x += 0.1
      player.size.y += 0.5
    } else {
      player.size.x -= 0.05
      player.size.y -= 0.25
    }
    
    // animation: Shake
    if(isTick) {
      player.pos.x += 1
      player.pos.y += 1
    } else {
      player.pos.x -= 1
      player.pos.y -= 1
    }
    
    // delay count up
    player.delayCounter += 1;
  }
  // update when input is released
  if (input.isJustReleased) {
    // color switch
    if (player.isCyan) {
      player.isCyan = false
    } else {
      player.isCyan = true
    }
    
    // player animation recovery (reset size and position)
    player.size = vec(G.PLAYER_WIDTH, G.PLAYER_HEIGHT)
    player.pos = vec(G.WIDTH * 0.1, G.HEIGHT * 0.5)
    
    // delay reset
    player.delayCounter = 0;
  }
  
  
  // UPDATE for hitbox
  // define slowdown boundaries
  hitbox.isSlowedDown = hitbox.pos.x >= G.WIDTH * 0.9 && hitbox.pos.x <= G.WIDTH * 0.95;
  // slowdown behavior
  if(hitbox.isSlowedDown) {
    hitbox.pos.x -= G.DEFAULT_SPEED * 0.1;
    hitbox.size.x = G.HITBOX_SIZE * 0.5
  } else {
    hitbox.pos.x -= G.DEFAULT_SPEED;
    hitbox.size.x = G.HITBOX_SIZE
  }
  // hitbox reset 
  if(hitbox.pos.x <= player.pos.x) {
    hitbox.pos.x = G.WIDTH + hitbox.size.x
    player.isHit = true;
  }
  
  // UPDATE for player
  if(player.isHit) {
    player.size.x = G.PLAYER_WIDTH * 0.5
    player.isHit = false;
  }
  
  if(player.size.x < G.PLAYER_WIDTH) {
    player.size.x += 0.3
  }
  
  if(player.size.x > G.PLAYER_WIDTH) {
    player.size.x = G.PLAYER_WIDTH
  }
  // RENDERER 
  //renderer for hitbox
  if(hitbox.isCyan) {
    color("cyan");
  } else {
    color("red");
  }
  
  box(hitbox.pos.x, hitbox.pos.y, hitbox.size.x, hitbox.size.y)
  
  // renderer for player
  if(player.delayCounter >= G.HOLD_DELAY) {
    // yellow when hold
    color("yellow");
    box(player.pos.x, player.pos.y, player.size.x, player.size.y);
  } else {
    // Color renderer (cyan / red)
    if(player.isCyan) {
      color("cyan");
      // Player collision box and game over condition
      if(box(player.pos.x, player.pos.y, player.size.x, player.size.y).isColliding.rect.red) {
        end();
      }
    } else {
      color("red");
      // Player collision box and game over condition
      if(box(player.pos.x, player.pos.y, player.size.x, player.size.y).isColliding.rect.cyan) {
        end();
      }
    }
  }
  
  // Particles
  if(!hitbox.isSlowedDown) {
    if(hitbox.isCyan) {
      color("cyan");
    } else {
      color("red");
    }
    
    particle(
        hitbox.pos.x + 2, // x coordinate
        hitbox.pos.y, // y coordinate
        4, // The number of particles
        1, // The speed of the particles
        -PI, // The emitting angle
        PI/2  // The emitting width
    );
  }
  
  if(player.size.x < G.PLAYER_WIDTH) {
    if(player.isCyan) {
      color("cyan")
    } else {
      color("red")
    }
    particle(
      player.pos.x + 5, // x coordinate
      player.pos.y, // y coordinate
      20, // The number of particles
      3, // The speed of the particles
      0, // The emitting angle
      3  // The emitting width
    );
  }
  
  // UPDATE for TICK TOCK
  // alternate boolean
  if(isTick) {
    isTick = false;
  } else {
    isTick = true;
  }
}

addEventListener("load", onLoad);
</script>

  </head>
  <body style="background: #ddd"></body>
</html>
